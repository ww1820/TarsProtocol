// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.16.
// **********************************************************************

#ifndef __NODEPUSH_H_
#define __NODEPUSH_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "NodeDescriptor.h"
#include "RegistryDescriptor.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace tars
{

    /* callback of async proxy for client */
    class NodePushPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~NodePushPrxCallback(){}
        virtual void callback_delCache(tars::Int32 requestId,  const std::string& nodeName,  const std::string& sFullCacheName,  const std::string& sBackupPath,  const std::string& sKey)
        { throw std::runtime_error("callback_delCache() override incorrect."); }
        virtual void callback_delCache_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_delCache_exception() override incorrect."); }
        virtual void callback_delCache(tars::Int32 requestId, std::string&&  nodeName, std::string&&  sFullCacheName, std::string&&  sBackupPath, std::string&&  sKey)
        { callback_delCache(requestId, nodeName, sFullCacheName, sBackupPath, sKey); }

        virtual void callback_destroyServer(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName)
        { throw std::runtime_error("callback_destroyServer() override incorrect."); }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_destroyServer_exception() override incorrect."); }
        virtual void callback_destroyServer(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName)
        { callback_destroyServer(requestId, nodeName, application, serverName); }

        virtual void callback_forceDockerLogin(tars::Int32 requestId,  const std::string& nodeName)
        { throw std::runtime_error("callback_forceDockerLogin() override incorrect."); }
        virtual void callback_forceDockerLogin_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_forceDockerLogin_exception() override incorrect."); }
        virtual void callback_forceDockerLogin(tars::Int32 requestId, std::string&&  nodeName)
        { callback_forceDockerLogin(requestId, nodeName); }

        virtual void callback_getLogData(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName,  const std::string& logFile,  const std::string& cmd)
        { throw std::runtime_error("callback_getLogData() override incorrect."); }
        virtual void callback_getLogData_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getLogData_exception() override incorrect."); }
        virtual void callback_getLogData(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName, std::string&&  logFile, std::string&&  cmd)
        { callback_getLogData(requestId, nodeName, application, serverName, logFile, cmd); }

        virtual void callback_getLogFileList(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName)
        { throw std::runtime_error("callback_getLogFileList() override incorrect."); }
        virtual void callback_getLogFileList_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getLogFileList_exception() override incorrect."); }
        virtual void callback_getLogFileList(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName)
        { callback_getLogFileList(requestId, nodeName, application, serverName); }

        virtual void callback_getNodeLoad(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName, tars::Int32 pid)
        { throw std::runtime_error("callback_getNodeLoad() override incorrect."); }
        virtual void callback_getNodeLoad_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getNodeLoad_exception() override incorrect."); }
        virtual void callback_getNodeLoad(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName, tars::Int32 pid)
        { callback_getNodeLoad(requestId, nodeName, application, serverName, pid); }

        virtual void callback_getPatchPercent(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName)
        { throw std::runtime_error("callback_getPatchPercent() override incorrect."); }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getPatchPercent_exception() override incorrect."); }
        virtual void callback_getPatchPercent(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName)
        { callback_getPatchPercent(requestId, nodeName, application, serverName); }

        virtual void callback_getStateInfo(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName)
        { throw std::runtime_error("callback_getStateInfo() override incorrect."); }
        virtual void callback_getStateInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getStateInfo_exception() override incorrect."); }
        virtual void callback_getStateInfo(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName)
        { callback_getStateInfo(requestId, nodeName, application, serverName); }

        virtual void callback_loadServer(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName)
        { throw std::runtime_error("callback_loadServer() override incorrect."); }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_loadServer_exception() override incorrect."); }
        virtual void callback_loadServer(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName)
        { callback_loadServer(requestId, nodeName, application, serverName); }

        virtual void callback_notifyServer(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName,  const std::string& command)
        { throw std::runtime_error("callback_notifyServer() override incorrect."); }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() override incorrect."); }
        virtual void callback_notifyServer(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName, std::string&&  command)
        { callback_notifyServer(requestId, nodeName, application, serverName, command); }

        virtual void callback_patchPro(tars::Int32 requestId,  const std::string& nodeName,  const tars::PatchRequest& req)
        { throw std::runtime_error("callback_patchPro() override incorrect."); }
        virtual void callback_patchPro_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_patchPro_exception() override incorrect."); }
        virtual void callback_patchPro(tars::Int32 requestId, std::string&&  nodeName, tars::PatchRequest&&  req)
        { callback_patchPro(requestId, nodeName, req); }

        virtual void callback_ping(tars::Int32 requestId,  const std::string& nodeName)
        { throw std::runtime_error("callback_ping() override incorrect."); }
        virtual void callback_ping_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_ping_exception() override incorrect."); }
        virtual void callback_ping(tars::Int32 requestId, std::string&&  nodeName)
        { callback_ping(requestId, nodeName); }

        virtual void callback_shutdown(tars::Int32 requestId,  const std::string& nodeName)
        { throw std::runtime_error("callback_shutdown() override incorrect."); }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_shutdown_exception() override incorrect."); }
        virtual void callback_shutdown(tars::Int32 requestId, std::string&&  nodeName)
        { callback_shutdown(requestId, nodeName); }

        virtual void callback_startServer(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName)
        { throw std::runtime_error("callback_startServer() override incorrect."); }
        virtual void callback_startServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_startServer_exception() override incorrect."); }
        virtual void callback_startServer(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName)
        { callback_startServer(requestId, nodeName, application, serverName); }

        virtual void callback_stopServer(tars::Int32 requestId,  const std::string& nodeName,  const std::string& application,  const std::string& serverName)
        { throw std::runtime_error("callback_stopServer() override incorrect."); }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopServer_exception() override incorrect."); }
        virtual void callback_stopServer(tars::Int32 requestId, std::string&&  nodeName, std::string&&  application, std::string&&  serverName)
        { callback_stopServer(requestId, nodeName, application, serverName); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __NodePush_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "ping",
                "shutdown",
                "startServer",
                "stopServer"
            };
            auto it = _msg_->response->status.find("TARS_FUNC");
            pair<string*, string*> r = equal_range(__NodePush_all, __NodePush_all+15, (it==_msg_->response->status.end())?_msg_->request.sFuncName:it->second);
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __NodePush_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string sFullCacheName;
                    _is.read(sFullCacheName, 3, true);
                    std::string sBackupPath;
                    _is.read(sBackupPath, 4, true);
                    std::string sKey;
                    _is.read(sKey, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_delCache(requestId, std::move(nodeName), std::move(sFullCacheName), std::move(sBackupPath), std::move(sKey));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_destroyServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_forceDockerLogin(requestId, std::move(nodeName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    std::string logFile;
                    _is.read(logFile, 5, true);
                    std::string cmd;
                    _is.read(cmd, 6, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getLogData(requestId, std::move(nodeName), std::move(application), std::move(serverName), std::move(logFile), std::move(cmd));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getLogFileList(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    tars::Int32 pid;
                    _is.read(pid, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getNodeLoad(requestId, std::move(nodeName), std::move(application), std::move(serverName), pid);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getPatchPercent(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getStateInfo(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_loadServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    std::string command;
                    _is.read(command, 5, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_notifyServer(requestId, std::move(nodeName), std::move(application), std::move(serverName), std::move(command));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    tars::PatchRequest req;
                    _is.read(req, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_patchPro(requestId, std::move(nodeName), std::move(req));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_ping_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_ping(requestId, std::move(nodeName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_shutdown(requestId, std::move(nodeName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_startServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Int32 requestId;
                    _is.read(requestId, 1, true);
                    std::string nodeName;
                    _is.read(nodeName, 2, true);
                    std::string application;
                    _is.read(application, 3, true);
                    std::string serverName;
                    _is.read(serverName, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_stopServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<NodePushPrxCallback> NodePushPrxCallbackPtr;

    //callback of promise async proxy for client
    class NodePushPrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~NodePushPrxCallbackPromise(){}
    public:
        struct PromisedelCache: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string sFullCacheName;
            std::string sBackupPath;
            std::string sKey;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisedelCache > PromisedelCachePtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisedelCachePtr > &promise)
        : _promise_delCache(promise)
        {}
        
        virtual void callback_delCache(const NodePushPrxCallbackPromise::PromisedelCachePtr &ptr)
        {
            _promise_delCache.setValue(ptr);
        }
        virtual void callback_delCache_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:delCache_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_delCache.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisedelCachePtr > _promise_delCache;

    public:
        struct PromisedestroyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisedestroyServer > PromisedestroyServerPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisedestroyServerPtr > &promise)
        : _promise_destroyServer(promise)
        {}
        
        virtual void callback_destroyServer(const NodePushPrxCallbackPromise::PromisedestroyServerPtr &ptr)
        {
            _promise_destroyServer.setValue(ptr);
        }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:destroyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_destroyServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisedestroyServerPtr > _promise_destroyServer;

    public:
        struct PromiseforceDockerLogin: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromiseforceDockerLogin > PromiseforceDockerLoginPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromiseforceDockerLoginPtr > &promise)
        : _promise_forceDockerLogin(promise)
        {}
        
        virtual void callback_forceDockerLogin(const NodePushPrxCallbackPromise::PromiseforceDockerLoginPtr &ptr)
        {
            _promise_forceDockerLogin.setValue(ptr);
        }
        virtual void callback_forceDockerLogin_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:forceDockerLogin_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_forceDockerLogin.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromiseforceDockerLoginPtr > _promise_forceDockerLogin;

    public:
        struct PromisegetLogData: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            std::string logFile;
            std::string cmd;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisegetLogData > PromisegetLogDataPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisegetLogDataPtr > &promise)
        : _promise_getLogData(promise)
        {}
        
        virtual void callback_getLogData(const NodePushPrxCallbackPromise::PromisegetLogDataPtr &ptr)
        {
            _promise_getLogData.setValue(ptr);
        }
        virtual void callback_getLogData_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogData_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getLogData.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisegetLogDataPtr > _promise_getLogData;

    public:
        struct PromisegetLogFileList: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisegetLogFileList > PromisegetLogFileListPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisegetLogFileListPtr > &promise)
        : _promise_getLogFileList(promise)
        {}
        
        virtual void callback_getLogFileList(const NodePushPrxCallbackPromise::PromisegetLogFileListPtr &ptr)
        {
            _promise_getLogFileList.setValue(ptr);
        }
        virtual void callback_getLogFileList_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getLogFileList_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getLogFileList.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisegetLogFileListPtr > _promise_getLogFileList;

    public:
        struct PromisegetNodeLoad: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            tars::Int32 pid;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisegetNodeLoad > PromisegetNodeLoadPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisegetNodeLoadPtr > &promise)
        : _promise_getNodeLoad(promise)
        {}
        
        virtual void callback_getNodeLoad(const NodePushPrxCallbackPromise::PromisegetNodeLoadPtr &ptr)
        {
            _promise_getNodeLoad.setValue(ptr);
        }
        virtual void callback_getNodeLoad_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getNodeLoad_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getNodeLoad.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisegetNodeLoadPtr > _promise_getNodeLoad;

    public:
        struct PromisegetPatchPercent: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisegetPatchPercent > PromisegetPatchPercentPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisegetPatchPercentPtr > &promise)
        : _promise_getPatchPercent(promise)
        {}
        
        virtual void callback_getPatchPercent(const NodePushPrxCallbackPromise::PromisegetPatchPercentPtr &ptr)
        {
            _promise_getPatchPercent.setValue(ptr);
        }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPercent_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getPatchPercent.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisegetPatchPercentPtr > _promise_getPatchPercent;

    public:
        struct PromisegetStateInfo: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisegetStateInfo > PromisegetStateInfoPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisegetStateInfoPtr > &promise)
        : _promise_getStateInfo(promise)
        {}
        
        virtual void callback_getStateInfo(const NodePushPrxCallbackPromise::PromisegetStateInfoPtr &ptr)
        {
            _promise_getStateInfo.setValue(ptr);
        }
        virtual void callback_getStateInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getStateInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getStateInfo.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisegetStateInfoPtr > _promise_getStateInfo;

    public:
        struct PromiseloadServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromiseloadServer > PromiseloadServerPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromiseloadServerPtr > &promise)
        : _promise_loadServer(promise)
        {}
        
        virtual void callback_loadServer(const NodePushPrxCallbackPromise::PromiseloadServerPtr &ptr)
        {
            _promise_loadServer.setValue(ptr);
        }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:loadServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_loadServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromiseloadServerPtr > _promise_loadServer;

    public:
        struct PromisenotifyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            std::string command;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisenotifyServer > PromisenotifyServerPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisenotifyServerPtr > &promise)
        : _promise_notifyServer(promise)
        {}
        
        virtual void callback_notifyServer(const NodePushPrxCallbackPromise::PromisenotifyServerPtr &ptr)
        {
            _promise_notifyServer.setValue(ptr);
        }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:notifyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_notifyServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisenotifyServerPtr > _promise_notifyServer;

    public:
        struct PromisepatchPro: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            tars::PatchRequest req;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisepatchPro > PromisepatchProPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisepatchProPtr > &promise)
        : _promise_patchPro(promise)
        {}
        
        virtual void callback_patchPro(const NodePushPrxCallbackPromise::PromisepatchProPtr &ptr)
        {
            _promise_patchPro.setValue(ptr);
        }
        virtual void callback_patchPro_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:patchPro_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_patchPro.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisepatchProPtr > _promise_patchPro;

    public:
        struct Promiseping: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::Promiseping > PromisepingPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisepingPtr > &promise)
        : _promise_ping(promise)
        {}
        
        virtual void callback_ping(const NodePushPrxCallbackPromise::PromisepingPtr &ptr)
        {
            _promise_ping.setValue(ptr);
        }
        virtual void callback_ping_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:ping_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_ping.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisepingPtr > _promise_ping;

    public:
        struct Promiseshutdown: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::Promiseshutdown > PromiseshutdownPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromiseshutdownPtr > &promise)
        : _promise_shutdown(promise)
        {}
        
        virtual void callback_shutdown(const NodePushPrxCallbackPromise::PromiseshutdownPtr &ptr)
        {
            _promise_shutdown.setValue(ptr);
        }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:shutdown_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_shutdown.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromiseshutdownPtr > _promise_shutdown;

    public:
        struct PromisestartServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisestartServer > PromisestartServerPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisestartServerPtr > &promise)
        : _promise_startServer(promise)
        {}
        
        virtual void callback_startServer(const NodePushPrxCallbackPromise::PromisestartServerPtr &ptr)
        {
            _promise_startServer.setValue(ptr);
        }
        virtual void callback_startServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:startServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_startServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisestartServerPtr > _promise_startServer;

    public:
        struct PromisestopServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 requestId;
            std::string nodeName;
            std::string application;
            std::string serverName;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePushPrxCallbackPromise::PromisestopServer > PromisestopServerPtr;

        NodePushPrxCallbackPromise(const tars::Promise< NodePushPrxCallbackPromise::PromisestopServerPtr > &promise)
        : _promise_stopServer(promise)
        {}
        
        virtual void callback_stopServer(const NodePushPrxCallbackPromise::PromisestopServerPtr &ptr)
        {
            _promise_stopServer.setValue(ptr);
        }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopServer.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< NodePushPrxCallbackPromise::PromisestopServerPtr > _promise_stopServer;

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __NodePush_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "ping",
                "shutdown",
                "startServer",
                "stopServer"
            };

            pair<string*, string*> r = equal_range(__NodePush_all, __NodePush_all+15, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __NodePush_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisedelCachePtr ptr = new NodePushPrxCallbackPromise::PromisedelCache();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->sFullCacheName, 3, true);
                        _is.read(ptr->sBackupPath, 4, true);
                        _is.read(ptr->sKey, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_delCache(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisedestroyServerPtr ptr = new NodePushPrxCallbackPromise::PromisedestroyServer();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_destroyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromiseforceDockerLoginPtr ptr = new NodePushPrxCallbackPromise::PromiseforceDockerLogin();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_forceDockerLogin(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisegetLogDataPtr ptr = new NodePushPrxCallbackPromise::PromisegetLogData();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                        _is.read(ptr->logFile, 5, true);
                        _is.read(ptr->cmd, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getLogData(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisegetLogFileListPtr ptr = new NodePushPrxCallbackPromise::PromisegetLogFileList();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getLogFileList(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisegetNodeLoadPtr ptr = new NodePushPrxCallbackPromise::PromisegetNodeLoad();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                        _is.read(ptr->pid, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getNodeLoad(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisegetPatchPercentPtr ptr = new NodePushPrxCallbackPromise::PromisegetPatchPercent();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getPatchPercent(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisegetStateInfoPtr ptr = new NodePushPrxCallbackPromise::PromisegetStateInfo();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getStateInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromiseloadServerPtr ptr = new NodePushPrxCallbackPromise::PromiseloadServer();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_loadServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisenotifyServerPtr ptr = new NodePushPrxCallbackPromise::PromisenotifyServer();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                        _is.read(ptr->command, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_notifyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisepatchProPtr ptr = new NodePushPrxCallbackPromise::PromisepatchPro();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->req, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_patchPro(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_ping_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisepingPtr ptr = new NodePushPrxCallbackPromise::Promiseping();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_ping_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_ping_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_ping(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromiseshutdownPtr ptr = new NodePushPrxCallbackPromise::Promiseshutdown();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_shutdown(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisestartServerPtr ptr = new NodePushPrxCallbackPromise::PromisestartServer();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_startServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    NodePushPrxCallbackPromise::PromisestopServerPtr ptr = new NodePushPrxCallbackPromise::PromisestopServer();

                    try
                    {
                        _is.read(ptr->requestId, 1, true);
                        _is.read(ptr->nodeName, 2, true);
                        _is.read(ptr->application, 3, true);
                        _is.read(ptr->serverName, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_stopServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<NodePushPrxCallbackPromise> NodePushPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class NodePushCoroPrxCallback: public NodePushPrxCallback
    {
    public:
        virtual ~NodePushCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __NodePush_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "ping",
                "shutdown",
                "startServer",
                "stopServer"
            };

            pair<string*, string*> r = equal_range(__NodePush_all, __NodePush_all+15, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __NodePush_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string sFullCacheName;
                        _is.read(sFullCacheName, 3, true);
                        std::string sBackupPath;
                        _is.read(sBackupPath, 4, true);
                        std::string sKey;
                        _is.read(sKey, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_delCache(requestId, std::move(nodeName), std::move(sFullCacheName), std::move(sBackupPath), std::move(sKey));

                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_destroyServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_forceDockerLogin_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_forceDockerLogin(requestId, std::move(nodeName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_forceDockerLogin_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogData_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        std::string logFile;
                        _is.read(logFile, 5, true);
                        std::string cmd;
                        _is.read(cmd, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_getLogData(requestId, std::move(nodeName), std::move(application), std::move(serverName), std::move(logFile), std::move(cmd));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogData_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLogFileList_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getLogFileList(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLogFileList_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNodeLoad_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        tars::Int32 pid;
                        _is.read(pid, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getNodeLoad(requestId, std::move(nodeName), std::move(application), std::move(serverName), pid);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNodeLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getPatchPercent(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getStateInfo(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_loadServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        std::string command;
                        _is.read(command, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_notifyServer(requestId, std::move(nodeName), std::move(application), std::move(serverName), std::move(command));

                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        tars::PatchRequest req;
                        _is.read(req, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_patchPro(requestId, std::move(nodeName), std::move(req));

                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_ping_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_ping(requestId, std::move(nodeName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_ping_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_ping_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_shutdown(requestId, std::move(nodeName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_startServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Int32 requestId;
                        _is.read(requestId, 1, true);
                        std::string nodeName;
                        _is.read(nodeName, 2, true);
                        std::string application;
                        _is.read(application, 3, true);
                        std::string serverName;
                        _is.read(serverName, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_stopServer(requestId, std::move(nodeName), std::move(application), std::move(serverName));

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<NodePushCoroPrxCallback> NodePushCoroPrxCallbackPtr;

    /* proxy for client */
    class NodePushProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        void delCache(tars::Int32 &requestId,std::string &nodeName,std::string &sFullCacheName,std::string &sBackupPath,std::string &sKey,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(sFullCacheName, 3);
            _os.write(sBackupPath, 4);
            _os.write(sKey, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"delCache", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(sFullCacheName, 3, true);
            _is.read(sBackupPath, 4, true);
            _is.read(sKey, 5, true);
        }

        void async_delCache(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisedelCachePtr > promise_async_delCache(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisedelCachePtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_delCache(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os, context, _mStatus, callback, true);
        }

        void destroyServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
        }

        void async_destroyServer(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisedestroyServerPtr > promise_async_destroyServer(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisedestroyServerPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_destroyServer(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os, context, _mStatus, callback, true);
        }

        void forceDockerLogin(tars::Int32 &requestId,std::string &nodeName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
        }

        void async_forceDockerLogin(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromiseforceDockerLoginPtr > promise_async_forceDockerLogin(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromiseforceDockerLoginPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_forceDockerLogin(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"forceDockerLogin", _os, context, _mStatus, callback, true);
        }

        void getLogData(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,std::string &logFile,std::string &cmd,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            _os.write(logFile, 5);
            _os.write(cmd, 6);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getLogData", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
            _is.read(logFile, 5, true);
            _is.read(cmd, 6, true);
        }

        void async_getLogData(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisegetLogDataPtr > promise_async_getLogData(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisegetLogDataPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogData(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogData", _os, context, _mStatus, callback, true);
        }

        void getLogFileList(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
        }

        void async_getLogFileList(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisegetLogFileListPtr > promise_async_getLogFileList(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisegetLogFileListPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLogFileList(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLogFileList", _os, context, _mStatus, callback, true);
        }

        void getNodeLoad(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::Int32 &pid,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            _os.write(pid, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
            _is.read(pid, 5, true);
        }

        void async_getNodeLoad(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisegetNodeLoadPtr > promise_async_getNodeLoad(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisegetNodeLoadPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNodeLoad(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNodeLoad", _os, context, _mStatus, callback, true);
        }

        void getPatchPercent(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
        }

        void async_getPatchPercent(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisegetPatchPercentPtr > promise_async_getPatchPercent(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisegetPatchPercentPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPercent(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os, context, _mStatus, callback, true);
        }

        void getStateInfo(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
        }

        void async_getStateInfo(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisegetStateInfoPtr > promise_async_getStateInfo(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisegetStateInfoPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getStateInfo(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os, context, _mStatus, callback, true);
        }

        void loadServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"loadServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
        }

        void async_loadServer(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromiseloadServerPtr > promise_async_loadServer(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromiseloadServerPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_loadServer(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os, context, _mStatus, callback, true);
        }

        void notifyServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,std::string &command,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            _os.write(command, 5);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
            _is.read(command, 5, true);
        }

        void async_notifyServer(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisenotifyServerPtr > promise_async_notifyServer(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisenotifyServerPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_notifyServer(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os, context, _mStatus, callback, true);
        }

        void patchPro(tars::Int32 &requestId,std::string &nodeName,tars::PatchRequest &req,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(req, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"patchPro", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(req, 3, true);
        }

        void async_patchPro(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisepatchProPtr > promise_async_patchPro(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisepatchProPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_patchPro(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os, context, _mStatus, callback, true);
        }

        void ping(tars::Int32 &requestId,std::string &nodeName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"ping", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
        }

        void async_ping(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"ping", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisepingPtr > promise_async_ping(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisepingPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"ping", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_ping(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"ping", _os, context, _mStatus, callback, true);
        }

        void shutdown(tars::Int32 &requestId,std::string &nodeName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"shutdown", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
        }

        void async_shutdown(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromiseshutdownPtr > promise_async_shutdown(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromiseshutdownPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_shutdown(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback, true);
        }

        void startServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"startServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
        }

        void async_startServer(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisestartServerPtr > promise_async_startServer(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisestartServerPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_startServer(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os, context, _mStatus, callback, true);
        }

        void stopServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(requestId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"stopServer", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            _is.read(requestId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
        }

        void async_stopServer(NodePushPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback);
        }
        
        tars::Future< NodePushPrxCallbackPromise::PromisestopServerPtr > promise_async_stopServer(const map<string, string>& context)
        {
            tars::Promise< NodePushPrxCallbackPromise::PromisestopServerPtr > promise;
            NodePushPrxCallbackPromisePtr callback = new NodePushPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopServer(NodePushCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os, context, _mStatus, callback, true);
        }

        NodePushProxy* tars_hash(uint32_t key)
        {
            return (NodePushProxy*)ServantProxy::tars_hash(key);
        }

        NodePushProxy* tars_consistent_hash(uint32_t key)
        {
            return (NodePushProxy*)ServantProxy::tars_consistent_hash(key);
        }

        NodePushProxy* tars_open_trace(bool traceParam = false)
        {
            return (NodePushProxy*)ServantProxy::tars_open_trace(traceParam);
        }

        NodePushProxy* tars_set_timeout(int msecond)
        {
            return (NodePushProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "NodePushProxy"; }
    };
    typedef tars::TC_AutoPtr<NodePushProxy> NodePushPrx;

    /* servant for server */
    class NodePush : public tars::Servant
    {
    public:
        virtual ~NodePush(){}
        virtual void delCache(tars::Int32 &requestId,std::string &nodeName,std::string &sFullCacheName,std::string &sBackupPath,std::string &sKey,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_delCache(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &sFullCacheName, const std::string &sBackupPath, const std::string &sKey)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("sFullCacheName", sFullCacheName);
                _tarsAttr_.put("sBackupPath", sBackupPath);
                _tarsAttr_.put("sKey", sKey);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["sFullCacheName"] = tars::JsonOutput::writeJson(sFullCacheName);
                _p->value["sBackupPath"] = tars::JsonOutput::writeJson(sBackupPath);
                _p->value["sKey"] = tars::JsonOutput::writeJson(sKey);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(sFullCacheName, 3);

                _os.write(sBackupPath, 4);

                _os.write(sKey, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_delCache(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &sFullCacheName, const std::string &sBackupPath, const std::string &sKey, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(sFullCacheName, 3);

                _os.write(sBackupPath, 4);

                _os.write(sKey, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"delCache", _os, _context);
            }
        }

        virtual void destroyServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_destroyServer(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_destroyServer(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"destroyServer", _os, _context);
            }
        }

        virtual void forceDockerLogin(tars::Int32 &requestId,std::string &nodeName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_forceDockerLogin(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_forceDockerLogin(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"forceDockerLogin", _os, _context);
            }
        }

        virtual void getLogData(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,std::string &logFile,std::string &cmd,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getLogData(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const std::string &logFile, const std::string &cmd)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);
                _tarsAttr_.put("logFile", logFile);
                _tarsAttr_.put("cmd", cmd);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                _p->value["logFile"] = tars::JsonOutput::writeJson(logFile);
                _p->value["cmd"] = tars::JsonOutput::writeJson(cmd);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _os.write(logFile, 5);

                _os.write(cmd, 6);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getLogData(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const std::string &logFile, const std::string &cmd, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _os.write(logFile, 5);

                _os.write(cmd, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getLogData", _os, _context);
            }
        }

        virtual void getLogFileList(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getLogFileList(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getLogFileList(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getLogFileList", _os, _context);
            }
        }

        virtual void getNodeLoad(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::Int32 &pid,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getNodeLoad(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, tars::Int32 pid)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);
                _tarsAttr_.put("pid", pid);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                _p->value["pid"] = tars::JsonOutput::writeJson(pid);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _os.write(pid, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getNodeLoad(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, tars::Int32 pid, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _os.write(pid, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getNodeLoad", _os, _context);
            }
        }

        virtual void getPatchPercent(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getPatchPercent(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getPatchPercent(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getPatchPercent", _os, _context);
            }
        }

        virtual void getStateInfo(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_getStateInfo(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_getStateInfo(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getStateInfo", _os, _context);
            }
        }

        virtual void loadServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_loadServer(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_loadServer(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"loadServer", _os, _context);
            }
        }

        virtual void notifyServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,std::string &command,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_notifyServer(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const std::string &command)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);
                _tarsAttr_.put("command", command);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                _p->value["command"] = tars::JsonOutput::writeJson(command);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _os.write(command, 5);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_notifyServer(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const std::string &command, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _os.write(command, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"notifyServer", _os, _context);
            }
        }

        virtual void patchPro(tars::Int32 &requestId,std::string &nodeName,tars::PatchRequest &req,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_patchPro(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const tars::PatchRequest &req)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("req", req);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["req"] = tars::JsonOutput::writeJson(req);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(req, 3);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_patchPro(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const tars::PatchRequest &req, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(req, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"patchPro", _os, _context);
            }
        }

        virtual void ping(tars::Int32 &requestId,std::string &nodeName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_ping(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_ping(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"ping", _os, _context);
            }
        }

        virtual void shutdown(tars::Int32 &requestId,std::string &nodeName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_shutdown(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_shutdown(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"shutdown", _os, _context);
            }
        }

        virtual void startServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_startServer(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_startServer(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"startServer", _os, _context);
            }
        }

        virtual void stopServer(tars::Int32 &requestId,std::string &nodeName,std::string &application,std::string &serverName,tars::TarsCurrentPtr _current_) = 0;
        static void async_response_stopServer(tars::TarsCurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName)
        {
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("requestId", requestId);
                _tarsAttr_.put("nodeName", nodeName);
                _tarsAttr_.put("application", application);
                _tarsAttr_.put("serverName", serverName);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                _p->value["application"] = tars::JsonOutput::writeJson(application);
                _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
        }
        static void async_response_push_stopServer(tars::CurrentPtr _current_, tars::Int32 requestId, const std::string &nodeName, const std::string &application, const std::string &serverName, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(requestId, 1);

                _os.write(nodeName, 2);

                _os.write(application, 3);

                _os.write(serverName, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"stopServer", _os, _context);
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __tars__NodePush_all[]=
            {
                "delCache",
                "destroyServer",
                "forceDockerLogin",
                "getLogData",
                "getLogFileList",
                "getNodeLoad",
                "getPatchPercent",
                "getStateInfo",
                "loadServer",
                "notifyServer",
                "patchPro",
                "ping",
                "shutdown",
                "startServer",
                "stopServer"
            };

            pair<string*, string*> r = equal_range(__tars__NodePush_all, __tars__NodePush_all+15, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __tars__NodePush_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string sFullCacheName;
                    std::string sBackupPath;
                    std::string sKey;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("sFullCacheName", sFullCacheName, sFullCacheName);
                        _tarsAttr_.getByDefault("sBackupPath", sBackupPath, sBackupPath);
                        _tarsAttr_.getByDefault("sKey", sKey, sKey);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(sFullCacheName, _jsonPtr->value["sFullCacheName"], false);
                        tars::JsonInput::readJson(sBackupPath, _jsonPtr->value["sBackupPath"], false);
                        tars::JsonInput::readJson(sKey, _jsonPtr->value["sKey"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(sFullCacheName, 3, false);
                        _is.read(sBackupPath, 4, false);
                        _is.read(sKey, 5, false);
                    }
                    delCache(requestId,nodeName,sFullCacheName,sBackupPath,sKey, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("sFullCacheName", sFullCacheName);
                            _tarsAttr_.put("sBackupPath", sBackupPath);
                            _tarsAttr_.put("sKey", sKey);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["sFullCacheName"] = tars::JsonOutput::writeJson(sFullCacheName);
                            _p->value["sBackupPath"] = tars::JsonOutput::writeJson(sBackupPath);
                            _p->value["sKey"] = tars::JsonOutput::writeJson(sKey);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(sFullCacheName, 3);
                            _os.write(sBackupPath, 4);
                            _os.write(sKey, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                    }
                    destroyServer(requestId,nodeName,application,serverName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                    }
                    forceDockerLogin(requestId,nodeName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    std::string logFile;
                    std::string cmd;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                        _tarsAttr_.getByDefault("logFile", logFile, logFile);
                        _tarsAttr_.getByDefault("cmd", cmd, cmd);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                        tars::JsonInput::readJson(logFile, _jsonPtr->value["logFile"], false);
                        tars::JsonInput::readJson(cmd, _jsonPtr->value["cmd"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                        _is.read(logFile, 5, false);
                        _is.read(cmd, 6, false);
                    }
                    getLogData(requestId,nodeName,application,serverName,logFile,cmd, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.put("logFile", logFile);
                            _tarsAttr_.put("cmd", cmd);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            _p->value["logFile"] = tars::JsonOutput::writeJson(logFile);
                            _p->value["cmd"] = tars::JsonOutput::writeJson(cmd);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.write(logFile, 5);
                            _os.write(cmd, 6);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                    }
                    getLogFileList(requestId,nodeName,application,serverName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    tars::Int32 pid;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                        _tarsAttr_.getByDefault("pid", pid, pid);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                        tars::JsonInput::readJson(pid, _jsonPtr->value["pid"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                        _is.read(pid, 5, false);
                    }
                    getNodeLoad(requestId,nodeName,application,serverName,pid, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.put("pid", pid);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            _p->value["pid"] = tars::JsonOutput::writeJson(pid);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.write(pid, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                    }
                    getPatchPercent(requestId,nodeName,application,serverName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                    }
                    getStateInfo(requestId,nodeName,application,serverName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                    }
                    loadServer(requestId,nodeName,application,serverName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    std::string command;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                        _tarsAttr_.getByDefault("command", command, command);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                        tars::JsonInput::readJson(command, _jsonPtr->value["command"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                        _is.read(command, 5, false);
                    }
                    notifyServer(requestId,nodeName,application,serverName,command, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.put("command", command);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            _p->value["command"] = tars::JsonOutput::writeJson(command);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.write(command, 5);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    tars::PatchRequest req;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("req", req, req);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(req, 3, false);
                    }
                    patchPro(requestId,nodeName,req, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("req", req);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["req"] = tars::JsonOutput::writeJson(req);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(req, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                    }
                    ping(requestId,nodeName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                    }
                    shutdown(requestId,nodeName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                    }
                    startServer(requestId,nodeName,application,serverName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 requestId;
                    std::string nodeName;
                    std::string application;
                    std::string serverName;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.getByDefault("requestId", requestId, requestId);
                        _tarsAttr_.getByDefault("nodeName", nodeName, nodeName);
                        _tarsAttr_.getByDefault("application", application, application);
                        _tarsAttr_.getByDefault("serverName", serverName, serverName);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(requestId, _jsonPtr->value["requestId"], false);
                        tars::JsonInput::readJson(nodeName, _jsonPtr->value["nodeName"], false);
                        tars::JsonInput::readJson(application, _jsonPtr->value["application"], false);
                        tars::JsonInput::readJson(serverName, _jsonPtr->value["serverName"], false);
                    }
                    else
                    {
                        _is.read(requestId, 1, false);
                        _is.read(nodeName, 2, false);
                        _is.read(application, 3, false);
                        _is.read(serverName, 4, false);
                    }
                    stopServer(requestId,nodeName,application,serverName, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("requestId", requestId);
                            _tarsAttr_.put("nodeName", nodeName);
                            _tarsAttr_.put("application", application);
                            _tarsAttr_.put("serverName", serverName);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["requestId"] = tars::JsonOutput::writeJson(requestId);
                            _p->value["nodeName"] = tars::JsonOutput::writeJson(nodeName);
                            _p->value["application"] = tars::JsonOutput::writeJson(application);
                            _p->value["serverName"] = tars::JsonOutput::writeJson(serverName);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(requestId, 1);
                            _os.write(nodeName, 2);
                            _os.write(application, 3);
                            _os.write(serverName, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
